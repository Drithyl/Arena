
var db;
var keys;
var characterModule;
var characterCreator;

module.exports =
{
  db: null,
  playerList: {},
  characterList: {},
  online: {},

  init: function(database, playersFetched, characterModule, characterCreator, index)
  {
    keys = index;
    db = database;
    characterModule = characterModule;
    characterCreator = characterCreator;

    for (var i = 0; i < playersFetched; i++)
    {
      revivePlayer(playersFetched[i]);
    }

    return this;
  },

  addOnline: function(username)
  {
    this.online[username] = this.playerList[username];
  },

  disconnect: function(username)
  {
    delete this.online[username];
  },

  getClientPack: function()
  {
    var obj = {};

    for (var key in this.online)
    {
      obj[key] = this.online[key].username;
    }

    return obj;
  },

  register: function(player, cb)
  {
    try
    {
      characterCreator.buildPlayerCharacters(player);
    }

    catch(err)
    {
      cb(err, null);
    }

    save(player, function(err, res)
    {
      if (err)
      {
        cb(err, null);
      }

      revivePlayer(player);
      this.addOnline(player.username);
      cb(null, true);
    });
  },

  /*
  * Reattach the relevant data to one player object on server launch and add it
  * to the list of players of this module.  Arguments:
  *
  *    player         A player object (usually generated by create()) to be
  *                   revived.
  *
  * This function may fail for several reasons:
  *
  *    Error          When calling characterManager.reviveCharacters(), an error
  *                   is thrown there, in which case this player will not be
  *                   added to the list.
  */

  revivePlayer: function(player)
  {
    revivePlayerCharacters(player);
    this.playerList[player.username] = player;
  },

  /*
  * Save the player's state in the database. This will also save the characters
  * state. Arguments:
  *
  *   player         The player object to be saved. Its format is explicitly
  *                  declared in the create() function of this module.
  *
  *   cb             The callback function called once the saving is done, or
  *                  when an error occurs.
  *
  * This function may fail for several reasons:
  *
  *   ThrownError    The saveCharacters() function called in the character module
  *                  throws an error, likely because it could not save a character
  *                  into the database.
  *
  *   DBError        The attempt to save the player in the database
  *                  threw an error, which is then passed into the callback.
  */

  save: function(player, cb)
  {
    var clone = player.functionless();

    for (var id in clone.characters)
    {
      characterModule.lullContent(clone.characters[id]);
    }

    db.save("players", clone, function(err, res)
    {
      if (err)
      {
        cb(err.name + ": in save(): " + err.message, null);
        return;
      }

      cb(null, res);
    });
  }
}

function revivePlayerCharacters(player)
{
  for (var i = 0; i < player.characters.length; i++)
  {
    reviveCharacter(player.characters[i]);
  }
}

function reviveCharacter(character)
{
  characterModule.reviveContent(character);
  characterModule.attachFunctions(character);
  this.characterList[character[keys.ID]] = character;
}
